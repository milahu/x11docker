#! /usr/bin/env bash

# x11docker
# Run GUI applications and desktop environments in Docker containers.
#
# - Runs additional X servers to circumvent common X security leaks.
# - Restricts container capabilities to enhance container security.
# - Container user is same as host user to avoid root in container.
# - Features e.g. sound, hardware acceleration and data storage.
#
# Run 'x11docker --help' or scroll down to read usage information.
# More documentation at:  https://github.com/mviereck/x11docker

Version="6.10.0"

# --enforce-i: Enforce running in interactive mode to allow commands tty and weston-launch in special setups.
grep -q -- "--enforce-i" <<< "$*" && case $- in
  *i*) set +H ;;
  *)   exec bash --noprofile --norc --noediting -i -- "$0" "$@" ;;
esac

. lib/usage.sh
. lib/license.sh

#### messages
. lib/alertbox.sh
. lib/debugnote.sh
. lib/error.sh
. lib/logentry.sh
. lib/note.sh
. lib/traperror.sh
. lib/verbose.sh
. lib/warning.sh
. lib/watchmessagefifo.sh

#### exit
. lib/finish.sh
. lib/finish_sigint.sh
. lib/saygoodbye.sh

#### watching processes
. lib/checkpid.sh
. lib/containerisrunning.sh
. lib/pspid.sh
. lib/rocknroll.sh
. lib/setonwatchpidlist.sh
. lib/storepid.sh
. lib/termpid.sh
. lib/waitfortheend.sh
. lib/watchpidlist.sh

#### more or less general routines
. lib/askyesno.sh
. lib/check_envvar.sh
. lib/check_parent_sshd.sh
. lib/download.sh
. lib/escapestring.sh
. lib/getrandomnumber.sh
. lib/isnum.sh
. lib/makecookie.sh
. lib/mysleep.sh
. lib/parse_inspect.sh
. lib/storeinfo.sh
. lib/rmcr.sh
. lib/timestamp.sh
. lib/unspecialstring.sh
. lib/verlt.sh
. lib/verlte.sh
. lib/wincmd.sh

#### file routines
. lib/convertpath.sh
. lib/getwslpath.sh
. lib/mkfile.sh
. lib/myrealpath.sh
. lib/waitforlogentry.sh
. lib/writeaccess.sh

#### special jobs of x11docker (not running X or docker)

. lib/buildimage.sh
. lib/cleanup.sh
. lib/create_launcher.sh
. lib/installer.sh

#### features
. lib/check_windowmanager.sh
. lib/clean_xhost.sh
. lib/setup_clipboard.sh
. lib/setup_gpu.sh
. lib/setup_hostdbus.sh
. lib/setup_printer.sh
. lib/setup_sound_alsa.sh
. lib/setup_sound_pulseaudio.sh
. lib/setup_webcam.sh

#### X server setup
. lib/check_newxenv.sh
. lib/check_screensize.sh
. lib/check_vt.sh
. lib/check_xdepends.sh
. lib/check_xpraoption.sh
. lib/check_xserver.sh
. lib/create_xcommand.sh
. lib/disable_xhost.sh
. lib/weston_getoutputname.sh

#### X helper scripts
. lib/create_modelinefile.sh
. lib/create_xdummywrapper.sh

if [ -x "/usr/libexec/Xorg" ]; then
	#Fedora 22+ workaround where /usr/bin/Xorg is not suid
	#because it is a script, command -v calls /usr/libexec/Xorg.wrap
	#command -v is setuid, and command -v eventually calls this one:
	XORG_BIN="/usr/libexec/Xorg"
elif [ -x "/usr/libexec/Xorg.bin" ]; then
	#Fedora 21 workaround where /usr/bin/Xorg is not suid
	#because it is a script, command -v calls /usr/libexec/Xorg.wrap
	#command -v is setuid, and command -v eventually calls this one:
	XORG_BIN="/usr/libexec/Xorg.bin"
elif [ -x "/usr/lib/xorg-server/Xorg" ]; then
	#Arch Linux:
	exec "/usr/lib/xorg-server/Xorg" "$@"
elif [ -x "/usr/lib/xorg/Xorg" ]; then
	#Ubuntu 16.10:
	exec "/usr/lib/xorg/Xorg" "$@"
else
	XORG_BIN="$(command -v Xorg)"
fi
if [ ! -x "$XORG_BIN" ]; then
	echo "failed to locate Xorg binary to run"
	exit 1
fi
if [ -u "$XORG_BIN" ]; then
	# setuid is set, we need to do magic
	find_ld_linux
	if [ -n "$LD_LINUX" ]; then
		if [ -n "$BASH" ]; then
			#running in bash, can show a more helpful command name:
			exec -a "Xorg-nosuid" "$LD_LINUX" "$XORG_BIN" "$@"
		else
			exec "$LD_LINUX" "$XORG_BIN" "$@"
		fi
	else
		#fallback to making a copy of the binary:
		DOTXPRA_DIR="$HOME/.xpra"
		if [ ! -d "$DOTXPRA_DIR" ]; then
	 		mkdir "$DOTXPRA_DIR"
	 		chmod 700 "$DOTXPRA_DIR"
	 	fi
		NOSUID_XORG="$DOTXPRA_DIR/Xorg-nosuid"
	 	cp -f "$XORG_BIN" "$NOSUID_XORG"
	 	exec "$NOSUID_XORG" "$@"
	 fi
else
	# setuid is not set on xorg_bin
	exec "$XORG_BIN" "$@"
fi
'
} >> $Xorgwrapper
. lib/create_xdummyxorgconf.sh
. lib/create_xinitrc.sh >> $Xinitrc

#### docker command setup
. lib/check_containerhome.sh
. lib/check_containeruser.sh
. lib/create_dockercommand.sh
. lib/setup_capabilities.sh
. lib/setup_initsystem.sh
. lib/store_runoption.sh

#### docker helper scripts
. lib/create_containerrootrc.sh
# make stderr visible
exec 2>&1
# wait for all other services
echo 'Content of /etc/runit/runsvdir/default:'
ls -la /etc/runit/runsvdir/default/*
for Service in /etc/runit/runsvdir/default/* ; do waitforservice \\\$Service ;done
echo 'Current status of runit services:'
for Service in /etc/runit/runsvdir/default/* ; do sv status      \\\$Service ;done
/usr/local/bin/x11docker-agetty
\" > /etc/sv/x11docker/run"
      echo "chmod +x /etc/sv/x11docker/run"
      echo ""
     
      echo "echo \"#! /bin/sh
sv down x11docker
runit-init 0
init 0
shutdown -h 0
halt
\" > /etc/sv/x11docker/finish"
      echo "chmod +x /etc/sv/x11docker/finish"
      echo ""
      
      echo "ln -s /etc/sv/x11docker /etc/runit/runsvdir/default" #void
      echo "ln -s /etc/sv/x11docker /service"                    #alpine
      echo ""
      
      echo "[ -e /etc/runit/1 ] || echo '#!/usr/bin/env sh
set -eu
chmod 100 /etc/runit/stopit
/bin/run-parts --exit-on-error /etc/runit/1.d || exit 100
' >/etc/runit/1"
      echo "chmod +x /etc/runit/1"
      echo ""
      
      echo "[ -e /etc/runit/2 ] || echo '#!/usr/bin/env sh
set -eu
runsvdir -P /service \"log: ..................................................................\"
' >/etc/runit/2"
      echo "chmod +x /etc/runit/2"
      echo ""
      
      echo '[ -e /etc/runit/3 ] || echo "#!/usr/bin/env sh
set -eu
exec 2>&1
echo \"Waiting for services to stop...\"
sv -w196 force-stop /service/*
sv exit /service/*
# kill any other processes still running in the container
for ORPHAN_PID in $(ps --no-headers -eo \"%p,\" -o stat | tr -d \" \" | grep \"Z\" | cut -d, -f1); do
    timeout 5 /bin/sh -c \"kill \$ORPHAN_PID && wait \$ORPHAN_PID || kill -9 \$ORPHAN_PID\"
done
" >/etc/runit/3'
      echo "chmod +x /etc/runit/3"
      echo ""
      
      echo "touch /etc/runit/stopit"
    ;;
    openrc)
      echo "# --init=openrc"
      echo "# Create and enable x11docker service containing container command"
      echo "printf \"#!/sbin/openrc-run
name=x11docker
. lib/depend.sh
. lib/start.sh
\" > /etc/init.d/x11docker.service"
      echo ""
      echo "chmod +x /etc/init.d/x11docker.service"
      echo "rc-update add x11docker.service default"
      echo ""
      echo "# Tell openrc that it runs in docker container"
      echo "sed -e 's/#rc_sys=\"\"/rc_sys=\"docker\"/g' -i /etc/rc.conf"
    ;;
    sysvinit)
      echo "# --init=sysvinit"
      echo "# Adding x11docker start command to rc.local"
      echo "sed -i '/exit 0/d' /etc/rc.local"
      echo "echo \"/usr/local/bin/x11docker-agetty || echo \\\"x11docker: Exit code of x11docker-agetty: \\\$?\\\"
echo 'x11docker: rc.local sends shutdown -h now'
shutdown -h now
exit 0\" >> /etc/rc.local"
      echo "chmod +x /etc/rc.local"
    ;;
  esac
  echo ""

  echo "# disable getty in inittab"
  echo "[ -e /etc/inittab ] && sed -i 's/.*getty/##getty disabled by x11docker## \0/' /etc/inittab"
  echo ""

  case $Dbussystem in
    yes)
      echo     "# Set up DBus"
      echo     "command -v dbus-daemon && {"
      echo     '  Unservicelist="
                    org.bluez
                    org.bluez.obex
                    org.freedesktop.hostname1
                    org.freedesktop.network1
                    org.freedesktop.resolve1
                    org.freedesktop.secrets
                    org.freedesktop.systemd1
                    org.freedesktop.timedate1
                    org.freedesktop.Tracker1
                    org.freedesktop.Tracker1.Miner.Extract
                    org.freedesktop.UDisks2
                    org.freedesktop.UPower
                    org.gtk.vfs.UDisks2VolumeMonitor
                    org.opensuse.CupsPkHelper.Mechanism
                    com.deepin.daemon.Bluetooth
                    com.deepin.daemon.Grub2
                    com.deepin.daemon.Power
                    com.deepin.lastore
                    com.deepin.lastore.Smartmirror
                    com.deepin.sync.Daemon
                    com.deepin.sync.Helper
                    com.deepin.userexperience.Daemon
                    "'
      echo     '  for Service in /usr/share/dbus-1/system-services/* /usr/share/dbus-1/services/*; do' # find is not available on fedora
      echo     '    Name="$(cat $Service | grep Name= | cut -d= -f2)"'
      echo     '    Command="$(cat $Service | grep Exec= | cut -d= -f2)"'
      echo     '    echo "$Unservicelist" | grep -q -w "$Name" && {'
      echo     '      debugnote "DBus: Removing $Name: $Service"'
      echo     '      rm $Service'
      echo     '    }'
#      echo     '    [ -e "$Service" ] && [ "$Command" != "/bin/false" ] && debugnote "DBus: Found $Name: $Command"'
      echo     '    case $Name in'
      [ "$Initsystem" != "systemd" ] && {
        echo   '      org.freedesktop.systemd1|org.freedesktop.hostname1|org.freedesktop.locale1)'
        echo   '        debugnote "DBus: Removing $Name: $Service"'
        echo   '        rm "$Service"'
        echo   '      ;;'
      }
      echo     '      org.freedesktop.login1)'
      echo     '        debugnote "DBus: Found login service $Name: $Command"'
      [ "$Sharecgroup" = "no" ] && {
        echo   '        debugnote "DBus: $Name: Removing $Service"'
        echo   '        rm "$Service"'
        echo   '        echo "$Command" | grep -q elogind && {'
        echo   '          note "Found login service elogind.'
        echo   '  If you want to use it, enable option --sharecgroup."'
        echo   '        }'
      }
      echo     '      ;;'
      echo     '    esac'
      echo     '  done'
      echo     ''
      
      case $Initsystem in
        systemd)
          echo "  # Just assuming that a DBus service file will be present"
          echo "  systemctl unmask dbus"
          echo "  systemctl enable dbus"
        ;;
        sysvinit)
          echo "  echo '#!/bin/sh
### BEGIN INIT INFO
# Provides:          dbus
# Required-Start:    \$remote_fs \$syslog
# Required-Stop:     \$remote_fs \$syslog
# Default-Start:     2 3 4 5
# Default-Stop:
# Short-Description: D-Bus systemwide message bus
# Description:       D-Bus is a simple interprocess messaging system, used
#                    for sending messages between applications.
### END INIT INFO
# -*- coding: utf-8 -*-
# Debian init.d script for D-BUS
# Copyright © 2003 Colin Walters <walters@debian.org>
# Copyright © 2005 Sjoerd Simons <sjoerd@debian.org>
#
DAEMON=/usr/bin/dbus-daemon
UUIDGEN=/usr/bin/dbus-uuidgen
UUIDGEN_OPTS=--ensure
NAME=dbus
DAEMONUSER=messagebus
PIDDIR=/var/run/dbus
PIDFILE=\"\$PIDDIR/pid\"
DESC=\"system message bus\"
#
test -x \$DAEMON || exit 1
. /lib/lsb/init-functions
# Source defaults file; edit that file to configure this script.
PARAMS=""
if [ -e /etc/default/dbus ]; then
  . /etc/default/dbus
fi
. lib/create_machineid.sh
. lib/start_it_up.sh
. lib/shut_it_down.sh
. lib/reload_it.sh
case \$1 in
  start) start_it_up ;;
  stop)  shut_it_down ;;
  reload|force-reload) reload_it ;;
  restart)
    shut_it_down
    start_it_up
  ;;
  status) status_of_proc -p \$PIDFILE \$DAEMON \$NAME && exit 0 || exit \$? ;;
esac' > /etc/init.d/dbus"
          echo "  chmod +x /etc/init.d/dbus"
        ;;
        runit)
          echo "  [ -e /etc/sv/dbus ] || {"
          echo "    mkdir -p /etc/sv/dbus"
          echo "    echo '#!/bin/sh
[ ! -d /run/dbus ] && install -m755 -g 22 -o 22 -d /run/dbus
exec dbus-daemon --system --nofork --nopidfile' >/etc/sv/dbus/run"
          echo "    echo '#!/bin/sh
exec dbus-send --system / org.freedesktop.DBus.Peer.Ping > /dev/null 2> /dev/null' >/etc/sv/dbus/check"
          echo "    chmod +x /etc/sv/dbus/run /etc/sv/dbus/check"
          echo "  }"
          echo "  verbose 'DBus: enabling dbus service'"
          echo "  ln -s /etc/sv/dbus  /etc/runit/runsvdir/default"  # void
          echo "  ln -s /etc/sv/dbus  /service"                     # alpine
        ;;
        openrc)
          echo "  echo '#!/sbin/openrc-run
. lib/start.sh
. lib/stop.sh
. lib/reload.sh' >/etc/init.d/dbus && chmod +x /etc/init.d/dbus"
          echo "  verbose 'DBus: enabling dbus service'"
          echo "  rc-update add dbus default"
        ;;
      esac
      echo     "} || note 'DBus not found.
  Can not run DBus system daemon. Please install dbus in image.'"
    ;;
  esac
  echo ""
  
  echo "rocknroll || exit 64"
  echo ""

  # --lang
  while read Line; do
    echo "# --lang: Language locale"
    echo "verbose \"Searching for language locale matching $Line\""
    echo "Locales=\"\$(locale -a)\""
    echo "Langall=\"\$(cat /usr/share/i18n/SUPPORTED | grep -E 'UTF-8|utf8' | cut -d' ' -f1 | cut -d. -f1 | cut -d@ -f1 | sort | uniq)\""
    echo "Langland=\"\$(echo $Line | cut -d. -f1)\""
    echo "Langcontainer=''"
    echo ""
    echo "echo \"\$Langland\" | grep -q '_' || {"
    echo "  Langland=\"\$(echo \$Langland | tr '[:upper:]' '[:lower:]')_\$(echo \$Langland | tr '[:lower:]' '[:upper:]')\""
    echo "  echo \"\$Langall\" | grep -q \"\$Langland\" || {"
    echo "    echo \"\$Langall\" | grep -i -q \"$Line\" && {"
    echo "      Langland=\"\$(echo \"\$Langall\" | grep -i -m1 \"$Line\")\""
    echo "    }"
    echo "  }"
    echo "}"
    echo ""
    echo "Langland=\"\$(echo \"\$Langland\" | cut -d_ -f1 | tr '[:upper:]' '[:lower:]')_\$(echo \"\$Langland\" | cut -d_ -f2 | tr '[:lower:]' '[:upper:]')\""
    echo ""
    echo "echo \"\$Locales\" | grep -q \"\$Langland.UTF-8\" && Langcontainer=\"\$Langland.UTF-8\""
    echo "echo \"\$Locales\" | grep -q \"\$Langland.utf8\"  && Langcontainer=\"\$Langland.utf8\""
    echo ""
    echo "[ -z \"\$Langcontainer\" ] && {"
    echo "  [ -e /usr/share/i18n/SUPPORTED ] || note \"Option --lang: /usr/share/i18n/SUPPORTED not found.
  Please install package 'locales' in image (belongs to glibc).
  Look here to find a package for your image system:
  https://github.com/mviereck/x11docker/wiki/dependencies#dependencies-in-image\""
    echo ""
    echo "  Langcontainer=\"\$Langland.utf8\""
    echo "  note \"Option --lang: Generating language locale \$Langcontainer\"."
    echo ""
    echo "  command -v localedef >/dev/null || note 'Option --lang: Command localedef not found in image.
  Need it for language locale creation.
  Look here to find a package for your image system:
  https://github.com/mviereck/x11docker/wiki/dependencies#dependencies-in-image'"
    echo "  localedef --verbose --force -i \"\$Langland\" -f UTF-8 \$Langcontainer || verbose \"localedef exit code: \$?\""
    echo ""
    echo "  locale -a | grep -q \"\$Langcontainer\" || {"
    echo "    note \"Option --lang: Generation of locale \$Langcontainer failed.\""
    echo "    Langcontainer=''"
    echo "  }"
    echo "} || {"
    echo "  debugnote \"Option --lang: Found locale in image: \$Langcontainer\""
    echo "}"
    echo ""
    echo "[ \"\$Langcontainer\" ] && {"
    echo '  storeinfo locale="$Langcontainer"'
    echo "  echo \"LANG=\$Langcontainer\" > /etc/default/locale"
    echo "} || note 'Option --lang: Desired locale for '$Line' not found and not generated.'"
    echo ""
  done < <(tac <<< "$Langwunsch" | grep . ||:)
  [ "$Langwunsch" ] && {
    echo "debugnote \"Option --lang: Output of locale -a:"
    echo "\$(locale -a)\""
    echo ""
    echo "rocknroll || exit 64"
    echo ""
  }
  
  [ "$Dbussystem" = "yes" ] && {
    case $Initsystem in
      tini|none|dockerinit) echo "dbus-daemon --system --fork" ;;
    esac
  }
  
  # --runasroot command added here
  [ "$Runasroot" ] && {
    echo "# Custom setup root command added with option --runasroot"
    echo "$Runasroot"
    echo ""
  }

  echo "storeinfo containerrootrc=ready"   # signal for containerrc
  echo ""
  
  [ "$Switchcontaineruser" = "yes" ] && {   # if "no", containerrc is executed in command line $Dockercommand
    echo "# --init=$Initsystem"
    case $Initsystem in
      none|dockerinit)
#        echo "exec /usr/local/bin/x11docker-login"
        echo "exec /usr/local/bin/x11docker-agetty"
      ;;
      tini)
#        echo "exec $Tinicontainerpath -- /usr/local/bin/x11docker-agetty"
        echo "exec /usr/local/bin/x11docker-agetty"
      ;;
      sysvinit)
        echo "/usr/local/bin/x11docker-watch &"
        echo "exec /sbin/init"
      ;;
      openrc)
        echo "/usr/local/bin/x11docker-watch &"
        echo "command -v openrc-init && exec openrc-init || exec /sbin/init"
      ;;
      runit)
        echo "/usr/local/bin/x11docker-watch &"
        echo "[ -e /sbin/runit-init ] && exec runit-init || exec /sbin/init"
      ;;
      s6-overlay)
        echo "exec /init /usr/local/bin/x11docker-agetty"
      ;;
      systemd)
        echo 'Systemd=/lib/systemd/systemd'
        echo '[ -e "$Systemd" ] || Systemd=/bin/systemd'
        echo '[ -e "$Systemd" ] || Systemd=/sbin/systemd'
        echo '[ -e "$Systemd" ] || {'
        echo '  command -v systemctl && {'
        echo '    warning "Executable for systemd not found. Will try /sbin/init"'
        echo '    Systemd=/sbin/init'
        echo '  } || error "systemd not found in image (option --init=systemd)."'
        echo '}'
        echo 'exec $Systemd'
      ;;
    esac
  }
  return 0
} >> $Containerrootrc
. lib/create_dockerrc.sh"
  echo ""

  
  echo "# Check default runtime"
  echo "Runtime=\"\$( { grep 'Default Runtime' < '$Dockerinfofile' ||: ;} | awk '{print \$3}' )\""
  echo '[ -n "$Runtime" ] && {' 
  echo "  debugnote \"dockerrc: Found default container Runtime: \$Runtime\""
  echo "  debugnote \"dockerrc: All \$(grep 'Runtimes' < '$Dockerinfofile' ||: )\""
  echo "  [ \"\$Runtime\" != '$Runtime' ] && {"
  echo "    case \$Runtime in"
  echo "      kata-runtime)  warning 'Found default container runtime kata-runtime.
  Please run x11docker with --runtime=kata-runtime to avoid issues.' ;;"
  echo "      nvidia) [ '$Sharegpu' = 'yes' ] &&  warning 'Option --gpu: Found default container runtime nvidia.
  Please run x11docker with --runtime=nvidia to avoid issues.' ;;"
  echo "      runc|crun|oci) ;;"
  echo "      *) note \"Found unknown container runtime: \$Runtime
  Please report at:  https://github.com/mviereck/x11docker\" ;;"
  echo "    esac"
  echo "  }"
  echo "}"
  echo "Runtime='${Runtime:-UNDECLARED_RUNTIME}'"
  echo "debugnote \"dockerrc: Container Runtime: \$Runtime\""
  echo "storeinfo \"runtime=\$Runtime\""
  echo ""
  
  echo "# Refresh images.list for x11docker-gui" ### FIXME makes no sense with multiple backends. But list needed below.
  echo "$Containerbackendbin images 2>>$Containerlogfile | grep -v REPOSITORY | awk '{print \$1 \":\" \$2}' >>$Dockerimagelistfile.sort"
  echo "rmcr $Dockerimagelistfile.sort"
  echo "while read -r Line ; do"
  echo '  grep -q "<none>" <<<$Line || echo $Line >> '$Dockerimagelistfile
  echo "done < <(sort < $Dockerimagelistfile.sort)"
  echo "rm $Dockerimagelistfile.sort"
  echo ""

  echo "# Check if image $Imagename is available locally"
  echo "Imagepull=no"
  case $Pullimage in
    no) ;;
    always) echo "Imagepull=yes" ;;
#    yes) echo "$Containerbackendbin inspect $Imagename >>$Containerlogfile 2>&1 || Imagepull=yes" ;;
    yes) echo "$Containerbackendbin images | grep -q '^$Imagename ' || Imagepull=yes" ;;
    ask)
      [ "$Runsinterminal" = "yes" ] && {
        echo "grep -x -q '$Imagename' < $Dockerimagelistfile || grep -x -q '$Imagename:latest' < $Dockerimagelistfile || {"
        echo "  $Containerbackendbin images | grep -q '^$Imagename ' || {"
        echo "    echo $Imagename | grep -q 'x11docker/' && echo 'You can build images from x11docker repository with e.g.:
  x11docker --build $Imagename
'"
        echo "    echo 'Image $Imagename not found locally.' >&2"
        echo "    echo 'Do you want to pull it from docker hub?' >&2"
        echo "    askyesno && Imagepull=yes || error \"Image '$Imagename' not available locally and not pulled from docker hub.\""
        echo "  }"
        echo "}"
      }
    ;;
  esac
  echo ""
  
  echo "rocknroll || exit 64"
  echo ""

  echo "[ \"\$Imagepull\" = 'yes' ] && {"
  echo "  note \"Pulling image '$Imagename' from docker hub\""
  [ "$Runsinterminal" = "no" ] && case $Passwordneeded in
    no)  echo "  env DISPLAY='$Hostdisplay' DBUS_SESSION_BUS_ADDRESS='${DBUS_SESSION_BUS_ADDRESS:-}' bash           -c \"notify-send 'x11docker: Pulling image $Imagename'\" 2>/dev/null &" ;;
    yes) echo "  env DISPLAY='$Hostdisplay' DBUS_SESSION_BUS_ADDRESS='${DBUS_SESSION_BUS_ADDRESS:-}' su '$Hostuser' -c \"notify-send 'x11docker: Pulling image $Imagename'\" 2>/dev/null &" ;;
  esac
  echo "  $Sudo $Containerbackendbin pull $Imagename 1>&2 || error \"Pulling image '$Imagename' seems to have failed!\""
  echo "}"
  echo ""

  echo "rocknroll || exit 64"
  echo ""

  echo "Inspect=\"\$($Containerbackendbin inspect $Imagename)\""
  
  echo "# Check architecture"
  echo 'Containerarchitecture=$(parse_inspect "$Inspect" "Architecture")'
  echo "debugnote \"dockerrc: Image architecture: \$Containerarchitecture\""
  
  echo "# Check CMD"
  echo "[ -z \"\$Containercommand\" ] && {"
  echo "  # extract image command from image if not given on cli"
  echo '  Containercommand="$(parse_inspect "$Inspect" "Config" "Cmd")"'
  echo "  debugnote \"dockerrc: Image CMD: \$Containercommand\""
  echo "  echo \"\$Containercommand\" | grep -q $(convertpath share $Containerrc) && error 'Recursion error: Found CMD $(convertpath share $Containerrc) in image.
  Did you use 'docker commit' with an x11docker container?
  Please build new images with a Dockerfile instead of using docker commit,
  or provide a different container command.'"
  echo "}"
  echo ""
  
  
  echo "# Check USER"
  echo 'Imageuser="$(parse_inspect "$Inspect" "Config" "User")"'
  echo "debugnote \"dockerrc: Image USER: \$Imageuser\""
  case $Createcontaineruser in
    yes)
      echo "[ \"\$Imageuser\" ] && note \"Found 'USER \$Imageuser' in image."
      echo "  If you want to run with user \$Imageuser instead of host user $Containeruser,"
      echo "  than run with --user=RETAIN.\""
      echo "storeinfo containeruser=\"$Containeruser\""
    ;;
    no)
      echo 'storeinfo containeruser="${Imageuser:-root}"'
    ;;
  esac
  echo ""
  
  case $Noentrypoint in
    yes) echo "Entrypoint=" ;;
    no)
      echo     "# Check ENTRYPOINT"
      echo     'Entrypoint="$(parse_inspect "$Inspect" "Config" "Entrypoint")"'
      echo     "debugnote \"dockerrc: Image ENTRYPOINT: \$Entrypoint\""
      case $Initsystem in
        systemd|sysvinit|runit|openrc|tini)
          echo "echo \"\$Entrypoint\" | grep -qE 'tini|init|systemd' && {"
          echo "  note \"There seems to be an init system in ENTRYPOINT of image:
    \$Entrypoint
  Will disable it as x11docker already runs an init with option --$Initsystem.
  To allow this ENTRYPOINT, run x11docker with option --init=none.\""
          echo "  Entrypoint="
          echo "}"
          #echo "Exec=exec"
        ;;
        s6-overlay)
          echo "[ \"\$Entrypoint\" = '/init' ] && {"
          echo "  Entrypoint="
          echo "  [ \"\$Containercommand\" ] || Containercommand=\"sh -c 'while :; do sleep 10; done'\""
          echo "}"
        ;;
        none)
          echo "echo \"\$Entrypoint\" | grep -qE 'tini|init|systemd' && {"
          echo "  note \"There seems to be an init system in ENTRYPOINT of image:
  \$Entrypoint 
  Returning exit code of container command will fail.\""
          echo "  Exec=exec"
          echo "}"
        ;;
      esac
    ;;
  esac
  echo ""
  
  [ -z "$Workdir" ] && {
    echo "# Check WORKDIR"
    echo 'Workdir="$(parse_inspect "$Inspect" "Config" "Workdir")"'
    echo "debugnote \"dockerrc: Image WORKDIR: \$Workdir\""
    echo "[ \"\$Workdir\" ] && note \"Found 'WORKDIR \$Workdir' in image. 
  You can change it with option --workdir=DIR.\""
    echo ""
  }
  
  case "$Containersetup" in
    no) ;;
    yes)      
      echo "[ -z \"\$Containercommand\$Entrypoint\" ] && error 'No container command specified and no CMD or ENTRYPOINT found in image.'"
      echo ""
     
      echo     "######## Create $(basename $Containerrc) ########"
      echo     ""
      echo     "{ echo '#! /bin/sh'"
      #[ "$Debugmode" = "yes" ] && echo "echo 'set -x'"
      echo     "  echo ''"
      echo     "  echo '# $(basename $Containerrc)'"
      echo     "  echo '# Created startscript for docker run used as container command.'"
      echo     "  echo '# Runs as unprivileged user in container.'"
      echo     "  echo ''"
     
      [ "$Interactive" = "no" ] && {
        echo   "  echo 'exec >>$(convertpath share $Containerlogfile) 2>&1'"
      }
      echo     "  echo ''"
     
      echo     "  echo '$(declare -f mysleep)'"
      echo     "  echo '$(declare -f rocknroll)'"
      echo     "  echo '$(declare -f saygoodbye)'"
      echo     "  echo '$(declare -f storeinfo)'"
      echo     "  echo '$(declare -f waitforlogentry)'"
      echo     "  echo '$Messagefifofuncs'"
      echo     "  echo 'Messagefile=$(convertpath share $Messagefifo)'"
      echo     "  echo 'Storeinfofile=$(convertpath share $Storeinfofile)'"
      echo     "  echo 'Timetosaygoodbyefile=$(convertpath share $Timetosaygoodbyefile)'"
      echo     "  echo ''"
      
      echo     "  echo 'waitforlogentry $(basename $Containerrc) \$Storeinfofile containerrootrc=ready "" infinity'"
     
      echo     "  echo 'debugnote \"Running $(basename $Containerrc): Unprivileged user commands in container\"'"
      echo     "  echo ''"
     
      echo     '  echo "Containercommand=\"$Containercommand\""'
      echo     '  echo "Entrypoint=\"$Entrypoint\""'
      echo     "  echo ''"
      echo     "  echo 'verbose \"$(basename $Containerrc): Container system:'"
      echo     "  echo '\$(cat /etc/os-release 2>&1 ||:)\"'"
      echo     "  echo ''"
     
      echo     "} >> $Containerrc"
     
      [ "$Switchcontaineruser" = "yes" ] && {   ### FIXME try --format '{{json .ContainerConfig.Env}}'
        echo "echo '# Environment variables found in image:'   >> $Containerrc"
        echo "IFS=$'\n'"
        echo "while read -r Line; do"
        echo "  echo \"export \$(escapestring \"\$Line\")\"  >> $Containerrc"
        echo "done < <($Containerbackendbin run --rm --entrypoint env $Imagename env 2>>$Containerlogfile | rmcr | grep -v 'HOSTNAME=' )"
        echo "IFS=$' \t\n'"
      }
     
      echo     "{"
      echo     "  echo ''"
      echo     "  echo '# USER and HOME'"
      echo     "  echo 'Containeruser=\"\$(storeinfo dump containeruser)\"'"
      case $Createcontaineruser in
        yes)
          echo "  echo 'Containeruserhome=\"$Containeruserhome\"'"
        ;;
        no)
          case $Sharehome in
            no)
              echo "  echo 'Containeruserhome=\"\$(cat /etc/passwd | grep \"\$Containeruser:.:\" | cut -d: -f6)\"'"
              echo "  echo 'Containeruserhome=\"\${Containeruserhome:-/tmp/\$Containeruser}\"'"
              echo "  echo 'mkdir -p \"\$Containeruserhome\"'"
            ;;
            volume)
              echo "  echo 'Containeruserhome=\"$Containeruserhome\"'"    
            ;;
          esac
        ;;
      esac
      echo     "  echo 'export USER=\"\$Containeruser\"'"
      echo     "  echo '[ \"\$Containeruserhome\" ] && {'"
      echo     "  echo '  export HOME=\"\$Containeruserhome\"'"
      echo     "  echo '}'"
      echo     "  echo ''"
  
      echo     "  echo '# XDG_RUNTIME_DIR'"
      echo     "  echo 'Containeruseruid=\$(id -u \$Containeruser)'"
      echo     "  echo 'export XDG_RUNTIME_DIR=/tmp/XDG_RUNTIME_DIR'"
      echo     "  echo '[ -e /run/user/\$Containeruseruid ] && ln -s /run/user/\$Containeruseruid \$XDG_RUNTIME_DIR || mkdir -p -m700 \$XDG_RUNTIME_DIR'"
      echo     "  echo ''"
      
      # softlinks from shared folders to HOME
      [ "$Persistanthomevolume" != "$Containeruserhosthome" ] && { # not for --home=$HOME
        while read -r Line; do
          Path="$(convertpath container "$Line")"
          [ "$(cut -c1-5 <<< "$Line")" != "/dev/" ] && {
            [ "$Line" != "$Path" ] && {   # different for paths in HOME without --home
              case $Line in
                "$Containeruserhosthome") # --share=$HOME
                  echo "  echo 'ln -s \"$Path\" -T \"$Containeruserhome/home.host.$Containeruser\"'"                
                  Ungrep="$Ungrep|home.host.$Containeruser"
                ;;
                *)
                  echo "  echo 'mkdir -p $(dirname "$Line")'"
                  echo "  echo 'ln -s \"$Path\" -T \"$(dirname "$Line")\"'"
                  Ungrep="$Ungrep|$(basename "$Line")"
                ;;
              esac
            }
          }
        done < <(store_runoption dump volume)
      }
  
      echo     "  echo '# Copy files from /etc/skel into empty HOME'"
      echo     "  echo '[ -d \"\$HOME\" ] && {'"
      echo     "  echo '  [ -d /etc/skel ] && [ -z \"\$(ls -A \"\$Containeruserhome\" 2>/dev/null | grep -v -E \"gnupg$Ungrep\")\" ] && {'"
      echo     "  echo '    debugnote \"$(basename $Containerrc): HOME is empty. Copying from /etc/skel\"'"
      echo     "  echo '    cp -n -R /etc/skel/. \$Containeruserhome'"
      echo     "  echo '    :'"
      echo     "  echo '  } || {'"
      echo     "  echo '    debugnote \"$(basename $Containerrc): HOME is not empty. Not copying from /etc/skel\"'"
      echo     "  echo '  }'"
      echo     "  echo '}'"
      echo     "  echo ''"

      [ -n "$Newdisplay" ] && {
        echo   "  echo '# Create softlink to X unix socket'"
        echo   "  echo '[ -e /tmp/.X11-unix/X$Newdisplaynumber ] || ln -s /X$Newdisplaynumber /tmp/.X11-unix'"
        echo   "  echo ''"
      }
  
      [ "$Dbusrunsession" = "yes" ]  && {
        echo   "  echo '# Check for dbus user daemon command'"
        echo   "  echo 'command -v dbus-run-session >/dev/null && Dbus=dbus-run-session || note \"Option --dbus: dbus seems to be not installed.
  Cannot run a DBus user session. Please install package dbus in image.\"'"
        echo   "  echo ''"
      }
  
      case $Xserver in
        --tty)
          echo "  echo 'unset DISPLAY WAYLAND_DISPLAY XAUTHORITY'" ;;
        --weston|--kwin|--hostwayland)
          echo "  echo 'unset DISPLAY XAUTHORITY'" ;;
        *)
          echo "  echo 'unset WAYLAND_DISPLAY'" ;;
      esac
      echo     "  echo ''"
      [ "$Setupwayland" = "yes" ] && {
        echo   "  echo '# Wayland environment'"
        echo   "  echo 'export WAYLAND_DISPLAY=$Newwaylandsocket'"
        echo   "  echo 'ln -s /$Newwaylandsocket \$XDG_RUNTIME_DIR/$Newwaylandsocket'"
      } || {
        echo   "  echo 'export XDG_SESSION_TYPE=x11'"
      }
      echo     "  echo ''"

      echo     "  echo ''"
      echo     "  echo 'export TERM=xterm'"

      echo     "  echo 'storeinfo test locale && export LANG=\"\$(storeinfo dump locale)\"'"

      echo     "  echo '[ -e \"$Hostlocaltimefile\" ] || export TZ=$Hostutctime'"
      echo     "  echo '[ \"\$(date -Ihours)\" != \"$(date -Ihours)\" ] && export TZ=$Hostutctime'"

      echo     "  echo '[ \"\$DEBIAN_FRONTEND\" = noninteractive ] && unset DEBIAN_FRONTEND && export DEBIAN_FRONTEND'"
      echo     "  echo '[ \"\$DEBIAN_FRONTEND\" = newt ]           && unset DEBIAN_FRONTEND && export DEBIAN_FRONTEND'"

      echo     "  echo '# container environment (--env)'"
      while read -r Line ; do  ### FIXME '\\\' not transmitted
        echo   "  echo \"export '$Line'\""
#        echo "$Line" >&2
#        echo   "  echo \"export $(escapestring "$Line")\""
#        echo   "  echo \"export $(escapestring "$Line")\"" >&2
#        echo   "  echo \"export \\\"$(escapestring "$Line")\\\"\"" >&2
#        echo   "  echo \"export \\\"$(escapestring "$Line")\\\"\""
      done < <(store_runoption dump env)
      echo     "  echo ''"

      [ "$Xauthentication" = "yes" ] || echo "  echo 'unset XAUTHORITY && export XAUTHORITY'"

      echo     "  echo '[ -d \"\$HOME\" ] && cd \"\$HOME\"'"
      echo     '  [ "$Workdir" ] && echo "[ -d \"$Workdir\" ] && cd \"$Workdir\"    # WORKDIR in image"'
      echo     "  echo ''"
      echo     "  echo ''"

      echo     "  echo 'env >> $(convertpath share $Containerenvironmentfile)'"
      echo     "  echo 'verbose \"Container environment:'"
      echo     "  echo '\$(env | sort)\"'"
      echo     "  echo ''"
  
      [ "$Initsystem" = "systemd" ] && {
        echo   "  echo 'systemctl --user start  dbus'"
        echo   "  echo ''"
      }
  
      case $Interactive in
        no)
          echo "  echo 'tail -f $(convertpath share $Cmdstdoutlogfile)     2>/dev/null &'"
          echo "  echo 'tail -f $(convertpath share $Cmdstderrlogfile) >&2 2>/dev/null &'"
          echo "  echo \"exec \\\$Dbus sh $(convertpath share $Cmdrc) >>$(convertpath share $Cmdstdoutlogfile) 2>>$(convertpath share $Cmdstderrlogfile)\""
        ;;
        yes)
          echo "  echo \"\$Exec \\\$Dbus \$Entrypoint \$Containercommand\" <&0"
        ;;
      esac
      echo     "} >> $Containerrc"
      echo     "######## End of containerrc ########"
      echo ""
  
      echo "# Write containerrc into x11docker.log"
      echo "nl -ba >> $Logfile < $Containerrc"
      echo ""
      echo     "######## Create $(basename $Cmdrc) ########"
      echo     "{ echo '#! /bin/sh'"
      echo     "  echo '# Created startscript for cmdrc containing final container command'"
      echo     "  echo ''"
      echo     "  echo '$(declare -f storeinfo)'"
      echo     "  echo '$Messagefifofuncs'"
      echo     "  echo 'Messagefile=$(convertpath share $Messagefifo)'"
      echo     "  echo 'Storeinfofile=\"$(convertpath share $Storeinfofile)\"'"
      echo     "  echo ''"
      # --runasuser commands added here
      [ "$Runasuser" ] && {
        echo   "  echo '# Custom daemon commands added with option --runasuser'"
        for Line in "$Runasuser"; do
        echo   "  echo 'debugnote \"$(basename $Cmdrc): Adding command:
  $Line\"'"
          echo "  echo '$Line'"
        done
        echo   "  echo ''"
      }
      echo     "  echo \"debugnote \\\"$(basename $Cmdrc): Running container command: 
  \$Entrypoint \$Containercommand
  \\\"\""
      echo     "  echo ''"
      echo     "  echo \"\$Entrypoint \$Containercommand $( [ "$Forwardstdin" = "yes" ] && echo "<$(convertpath share $Cmdstdinfifo)" ) \""
      echo     "  echo \"storeinfo cmdexitcode=\\\$?\""
      echo     "  echo ''"
      echo     "  echo '[ -h \"\$Homesoftlink\" ] && rm \$Homesoftlink'"
      echo     "} >> $Cmdrc"
      echo     "######## End of cmdrc ########"
      echo ""
  
      echo "# Write cmdrc into x11docker.log"
      echo "nl -ba >> $Logfile < $Cmdrc"
      echo ""


      # check [and create] cgroup mountpoint for systemd or elogind
      [ "$Sharecgroup" = "yes" ] && [ "$Dbussystem" = "yes" ] && {
        [ "$Initsystem" = "systemd" ] && Wantcgroup=systemd || Wantcgroup=elogind
        findmnt /sys/fs/cgroup/$Wantcgroup >/dev/null || {
          echo   "# Check [and create] cgroup mountpoint for $Wantcgroup"
          echo   "[ '$Wantcgroup' = 'systemd' ] || $Containerbackendbin run --rm --entrypoint env $Imagename sh -c 'ls /lib/elogind/elogind || ls /usr/sbin/elogind|| ls /usr/libexec/elogind' && {"
          echo   '  [ "$(id -u)"  = "0" ] && note "Creating cgroup mountpoint for '$Wantcgroup'."'
          echo   '  [ "$(id -u)" != "0" ] && {'
          echo   "    note 'Want to create and mount a cgroup for $Wantcgroup.
  As x11docker currently does not run as root, this will probably fail.
  Please either run x11docker as root, or run with option --pw=su or --pw=sudo.
    
  Alternatively, create cgroup mountpoint yourself with:
    mkdir -p /sys/fs/cgroup/$Wantcgroup
    mount -t cgroup cgroup /sys/fs/cgroup/$Wantcgroup -o none,name=$Wantcgroup
    
  If you get a read-only error message, remove write protection with:
    mount -o remount,rw cgroup /sys/fs/cgroup
    
  You can restore write protection after cgroup creation with:
    mount -o remount,ro cgroup /sys/fs/cgroup'"
          [ "$Wantcgroup" = "elogind" ] && echo "note 'If you do not want or need elogind in container,
  just ignore message above.'"
          echo   "  }"
          findmnt /sys/fs/cgroup -O ro >/dev/null && {
            echo "  mount -o remount,rw cgroup /sys/fs/cgroup >>$Containerlogfile 2>&1"
            echo "  Remounted=yes"
          }
          echo   "  mkdir -p /sys/fs/cgroup/elogind >>$Containerlogfile 2>&1"
          echo   "  mount -t cgroup cgroup /sys/fs/cgroup/elogind -o none,name=elogind  >>$Containerlogfile 2>&1"
          echo   '  [ "${Remounted:-}" = "yes" ] && mount -o remount,ro cgroup /sys/fs/cgroup  >>'$Containerlogfile' 2>&1'
          echo   "}"
          echo   ""
        }
      }
  
    ;;
  esac
  
  echo "# Send signal to run X and wait for X to be ready"
  echo 'storeinfo readyforX=ready'
  echo "waitforlogentry 'dockerrc' $Xinitlogfile 'xinitrc is ready' '$Xiniterrorcodes'"
  echo ""
  
  echo "rocknroll || exit 64"
  echo ""
  
  echo "#### run docker image ####"
#      echo "$Dockercommand "
  case $Interactive in
    no)  
      echo "read Containerid < <($Dockercommand 2>>$Containerlogfile | rmcr)"
#      echo "read Containerid < <($Dockercommand | rmcr)" 
    ;;
    yes)
      #echo "docker run --rm -ti alpine sh <&0 &"
      [ "$Winpty" ] && echo "$Winpty bash $Dockercommandfile <&0 &" || echo "$Dockercommand <&0 &"
      echo "Containerid=$Containername"
    ;;
  esac
  echo "##########################"
  echo ""
  echo ""

  echo "[ \"\$Containerid\" ] || {
    error \"Startup of $Containerbackend failed. Did not receive a container ID.
    
  Last lines of container log:
\$(rmcr < $Containerlogfile | tail)\"
}"
  echo 'storeinfo containerid="$Containerid"'
  
  echo "# Wait for container to be ready"
  echo "for ((Count=1 ; Count<=40 ; Count++)); do"
  echo "  $Containerbackendbin exec $Containername sh -c : 2>&1 | rmcr >>$Containerlogfile && { debugnote 'dockerrc: Container is up and running.' ; break ; } || debugnote \"dockerrc: Container not ready on \$Count. attempt, trying again.\""
  echo "  rocknroll || exit 64"
  echo "  mysleep 0.1"
  echo "done"
  echo ""
  
  [ "$Containersetup" = "no" ] && {
#    echo "$Containerbackendbin logs -f \$Containerid >> $Containerlogfile 2>&1 &"
    echo "# Store container output separated for stdout and stderr"
    echo "$Containerbackendbin logs -f \$Containerid 1>>$Cmdstdoutlogfile 2>>$Cmdstderrlogfile &"
    echo "Dockerlogspid=\$!"
    echo "storepid \$Dockerlogspid dockerlogs"  
    echo ""
  }

  echo "# Wait for pid 1 in container"
  echo "for ((Count=1 ; Count<=40 ; Count++)); do"
  echo "  Inspect=\"\$($Containerbackendbin inspect $Containername 2>>$Containerlogfile | rmcr)\""
  echo '  [ "$Inspect" != "[]" ] && Pid1pid="$(parse_inspect "$Inspect" "State" "Pid")"'
  echo "  debugnote \"dockerrc: \$Count. check for PID 1: \$Pid1pid\""
    case $Mobyvm in
      no)  echo '  checkpid "$Pid1pid" && break' ;;
      yes) echo '  [ "$Pid1pid" ] && [ "$Pid1pid" != "0" ] && break' ;;
    esac
  echo "  rocknroll || exit 64"
  echo "  mysleep 0.1"
  echo "done"
  echo '[ "$Pid1pid" = "0" ] && Pid1pid=""'

  echo '[ -z "$Pid1pid" ] && error "dockerrc(): Did not receive PID of PID1 in container.
  Maybe the container immediately stopped for unknown reasons.
  Just in case, check if host and image architecture are compatible:
  Host architecture: '$Hostarchitecture', image architecture: $Containerarchitecture.
  Output of \"'$Containerbackend' ps | grep x11docker\":
$('$Containerbackendbin' ps | grep x11docker)
  
  Content of container log:
$(rmcr < '$Containerlogfile' | uniq )"'
  echo 'storeinfo pid1pid="$Pid1pid"'
  echo ""

  echo "# Get IP of container"
  echo 'Containerip="$(parse_inspect "$Inspect" "NetworkSettings" "IPAddress")"'
  echo 'storeinfo containerip=$Containerip'
  echo ""
  
  echo "# Check log for startup failure"
  echo "Failure=\"\$(rmcr < $Containerlogfile | grep -v grep | grep -E 'Error response from daemon|OCI runtime exec' ||:)\""
  echo "[ \"\$Failure\" ] && {"
  echo "  echo \"\$Failure\" >>$Containerlogfile"
  echo "  error \"Got error message from $Containerbackend:
\$Failure

  Last lines of logfile:
\$(tail $Containerlogfile)\""
  echo "}"
  echo ""
  
  [ "$Switchcontaineruser" = "no" ] && [ "$Containersetup" = "yes" ] && {
    echo "debugnote 'dockerrc(): Starting containerrootrc with docker exec'"
    echo "# copy containerrootrc inside of container to avoid possible noexec of host home."
    echo "$Containerbackendbin exec $Containername sh -c 'cp $(convertpath share $Containerrootrc) /tmp/containerrootrc ; chmod 644 /tmp/containerrootrc' 2>&1 | rmcr >>$Containerlogfile"
    echo "# run container root setup. containerrc will wait until setup script is ready."
    echo "$Containerbackendbin exec -u root $Containername /bin/sh /tmp/containerrootrc 2>&1 | rmcr >>$Containerlogfile"
    echo ""
  }
  
  echo "storeinfo dockerrc=ready"
  echo ""
  
  case $Mobyvm in
    no)
      echo '[ "$Containerid" ] && {'
      echo "  # wait for signal of finish()"
      echo "  read Signal <$Dockerstopsignalfifo"
      echo '  [ "$Signal" = "stop" ] && {'
      echo "    [ \"\$Containerid\" ]   && $Containerbackendbin stop \$Containerid     >> $Containerlogfile 2>&1 &"
      echo "    [ \"\$Dockerlogspid\" ] && kill \$Dockerlogspid              >> $Containerlogfile 2>&1 &"
      echo "  }"
      echo "} & storepid \$! dockerstopshell"
    ;;
  esac
  
  echo "exit 0"
  return 0
} >> $Dockerrc
. lib/create_xtermrc.sh >> $Xtermrc

#### final startup routines
. lib/start_compositor.sh
. lib/start_docker.sh
. lib/start_hostexe.sh 
. lib/start_pulseaudiotcp.sh
. lib/start_xpra.sh
. lib/start_xserver.sh

#### main init routines
. lib/check_fallback.sh
. lib/check_host.sh
. lib/check_hostuser.sh
. lib/check_hostxenv.sh
. lib/check_option_interferences.sh
. lib/check_passwordfrontend.sh
. lib/check_runmode.sh
. lib/check_terminalemulator.sh
. lib/create_cachefiles.sh
. lib/drop_cachefiles.sh
. lib/option_messages.sh
. lib/setup_fifo.sh
. lib/setup_verbosity.sh

#### main
. lib/declare_variables.sh
. lib/note.sh
. lib/verbose.sh
. lib/debugnote.sh
. lib/error.sh
. lib/stdout.sh'
  Messagefifofuncs_escaped='
. lib/warning.sh
. lib/note.sh
. lib/verbose.sh
. lib/debugnote.sh
. lib/error.sh
. lib/stdout.sh'
}
. lib/parse_options.sh
. lib/unpriv.sh
. lib/main.sh

main "$@"
